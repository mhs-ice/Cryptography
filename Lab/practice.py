def main():
    p = int(input("Enter the value of p of Ep(a,b): "))
    a = int(input("Enter the value of a of Ep(a,b): "))
    b = int(input("Enter the value of b of Ep(a,b): "))
    g_input = input("Enter the generator point G (format: x,y): ")
    g = tuple(map(int, g_input.split(',')))

    print(f"\nThe elliptic curve equation is: y² = x³ + {a}x + {b} mod {p}")
    print(f"Generator point G = {g}\n")

    def generate_subgroup(G):
        subgroup = []
        P = G
        i = 1
        while P != 'O':
            subgroup.append((i, P))
            P = point_add(P, G, a, p)
            i += 1
        subgroup.append((i, 'O'))
        return subgroup

    subgroup = generate_subgroup(g)
    print("Subgroup ⟨G⟩ generated by G :\n")
    for i, P in subgroup:
        print(f"{i}G = {P}")

    # ========== Key Exchange ==========
    print("\nKey Exchange Phase:")
    print("------------------")

    alpha = int(input("Enter Alice's private key alpha (1 ≤ alpha ≤ n-1): "))
    pa = point_multiply(alpha, g, a, p)
    print(f"Alice's public key P_A = alpha * G = {pa}")

    beta = int(input("Enter Bob's private key beta (1 ≤ beta ≤ n-1): "))
    pb = point_multiply(beta, g, a, p)
    print(f"Bob's public key P_B = beta * G = {pb}")

    alice_shared_key = point_multiply(alpha, pb, a, p)
    bob_shared_key = point_multiply(beta, pa, a, p)

    print(f"\nAlice computes shared key: alpha * P_B = {alice_shared_key}")
    print(f"Bob computes shared key: beta * P_A = {bob_shared_key}")
    print("Key exchange successful!" if alice_shared_key == bob_shared_key else "Key exchange failed!")

    # ========== Encryption/Decryption ==========
    print("\nEncryption/Decryption Phase:")
    print("---------------------------")

    pm = get_valid_point(p, a, b, "\nEnter message point P_m to encrypt (format: x,y): ")

    alpha_enc = int(input("Enter Alice's random integer alpha for encryption: "))
    c1 = point_multiply(alpha_enc, g, a, p)
    alpha_pb = point_multiply(alpha_enc, pb, a, p)
    c2 = point_add(pm, alpha_pb, a, p)
    ciphertext = (c1, c2)

    print(f"\nEncrypted ciphertext C_m = {ciphertext}")

    beta_c1 = point_multiply(beta, c1, a, p)
    beta_c1_inv = (beta_c1[0], (-beta_c1[1]) % p)
    decrypted = point_add(c2, beta_c1_inv, a, p)

    print(f"\nDecrypted message = {decrypted}")
    print(f"Original message was {pm}")
    print("Decryption successful!" if decrypted == pm else "Decryption failed!")

def point_add(P, Q, a, p):
    """Add two points P and Q on the elliptic curve y² = x³ + ax + b mod p"""
    if P == 'O':
        return Q
    if Q == 'O':
        return P

    x1, y1 = P
    x2, y2 = Q

    if x1 == x2 and (y1 + y2) % p == 0:
        return 'O'

    if P != Q:
        m = ((y2 - y1) * pow(x2 - x1, -1, p)) % p
    else:
        m = ((3 * x1 * x1 + a) * pow(2 * y1, -1, p)) % p

    x3 = (m * m - x1 - x2) % p
    y3 = (m * (x1 - x3) - y1) % p

    return (x3, y3)

def point_multiply(k, point, a, p):
    """Multiply a point by scalar k using the double-and-add method"""
    result = 'O'
    addend = point

    while k:
        if k & 1:
            result = point_add(result, addend, a, p)
        addend = point_add(addend, addend, a, p)
        k >>= 1

    return result

def is_point_on_curve(point, a, b, p):
    """Check if a point lies on the elliptic curve y² ≡ x³ + ax + b (mod p)"""
    if point == 'O':
        return True
    x, y = point
    return (y ** 2) % p == (x ** 3 + a * x + b) % p

def get_valid_point(p, a, b, prompt="Enter point (format: x,y): "):
    """Get and validate a point on the curve"""
    while True:
        try:
            point_input = input(prompt)
            x, y = map(int, point_input.split(','))
            if is_point_on_curve((x, y), a, b, p):
                return (x, y)
            else:
                print(f"Error: Point ({x}, {y}) is not on the curve")
        except ValueError:
            print("Please enter coordinates in format 'x,y'")
        except Exception as e:
            print(f"Error: {str(e)}")

if __name__ == "__main__":
    main()
